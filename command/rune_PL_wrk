#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/var/www/app/libs/runeaudio.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;

// --- WORKER MAIN LOOP --- //
while (1) {
    // Connect to Redis backend
    $redis = new Redis();
    $redis->pconnect('/run/redis/socket');
    // initialise variables
    $artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
    $artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
    if ($redis->get('remoteSSbigart') === 'album') {
        $bigartIsAlbum = true;
    } else {
        $bigartIsAlbum = false;
    }
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    if ($activePlayer === 'MPD') {
        runelog('rune_PL_wrk: open MPD local UNIX socket');
        $socket = openMpdSocket('/run/mpd/socket', 0);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    } else if ($activePlayer === 'Spotify') {
        runelog('rune_PL_wrk: open SPOP socket');
        $socket = openSpopSocket('localhost', 6602, 1);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    }

    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                ui_update($redis, $socket, 0);
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
            }
            $status['radio'] = false;
            $status = array();
            $status = _parseStatusResponse($redis, MpdStatus($socket));
            $status['mainArtURL'] = $artUrl.'/none.png';
            $status['smallArtURL'] = $artUrl.'/mpd/black.png';
            $status['bigArtURL'] = $artUrl.'/mpd/black.png';
            // store next songid
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            $redis->set('lastsongid', $status['songid']);
            $redis->set('pl_length', $status['playlistlength']);
            // set the mpd volume to the last value set via the UI, if a value is available and volume control is enabled
            // the streaming services can change the alsa volume, we want to change it back to the last set value
            set_last_mpd_volume($redis);
            do {
                // idle LOOP
                runelog('rune_PL_wrk: enter idle loop');
                $status = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$status) {
                    break;
                }
                // $monArray = monitorMpdState($redis, $socket);
                // // if we have lost the connection to mpd then break the loop
                // if (!$monArray) {
                    // break;
                // }
                // $status['currentartist'] = '';
                // $status['currentalbumartist'] = '';
                // $status['currentartist'] = '';
                // $status['currentalbum'] = '';
                // $status['currentsong'] = '';
                // $status = array_merge($status, $monArray);
                // store next songid
                $redis->set('nextsongid', $status['nextsongid']);
                // store "lastsongid"
                $redis->set('lastsongid', $status['songid']);
                $redis->set('pl_length', $status['playlistlength']);

                // runelog('---------status data------------',$status);
                $status = ui_status($socket, $status);
                runelog('---------status data(2)------------',$status);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync('ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}


                $status['radio'] = false;
                if ((!isset($status['currentalbum']) || !$status['currentalbum']) && (!isset($status['radioname']) || !$status['radioname'])) {
                    if (isset($radioUrl) && $radioUrl && ($radioUrl === $status['file'])) {
                        $status['currentalbum'] = $radioName;
                        $status['radioname'] = $radioName;
                        $status['radio'] = true;
                    } else {
                        $radioName = is_radioUrl($redis, $status['file']);
                        if ($radioName) {
                            $radioUrl = $status['file'];
                            $status['currentalbum'] = $radioName;
                            $status['radioname'] = $radioName;
                            $status['radio'] = true;
                        } else {
                            $radioUrl = '';
                        }
                    }
                }

                // decode radio song name and determine the metadata and albumart
                $rts = 0;
                if (isset($status['radioname']) && $status['radioname'] && (!isset($status['currentartist']) || !$status['currentartist'])) {
                    runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                    if (isset($status['currentsong']) && $status['currentsong']) {
                        $rts = time();
                        runelog('rune_PL_wrk: radio currentsong = ', $status['currentsong']);
                        $retval = wrk_get_webradio_art($redis, $status['currentsong']);
                        $rts = time() - $rts;
                    } else {
                        $retval = false;
                        $status['currentsong'] = '';
                    }
                    $status['fileext'] = '';
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                    $status['bigArtURL'] = $artUrl.'/none.png';
                    $status['smallArtURL'] = $artUrl.'/none.png';
                    $status['currentalbum'] = $status['radioname'];
                    $status['currentalbumartist'] = '';
                    $status['currentartist'] = '';
                    if ($retval) {
                        ui_notify('Radio success ', $rts.' seconds, change status '.$status['changed']);
                        if ($retval['song']) {
                            $status['currentsong'] = $retval['song'];
                        }
                        if ($retval['song_lyrics']) {
                            $status['song_lyrics'] = $retval['song_lyrics'];
                        }
                        if ($retval['artist']) {
                            $status['currentartist'] = $retval['artist'];
                            $status['currentalbumartist'] = $retval['artist'];
                        }
                        if ($retval['artist_bio_summary']) {
                            $status['artist_bio_summary'] = $retval['artist_bio_summary'];
                        }
                        if ($retval['artist_similar']) {
                            $status['artist_similar'] = $retval['artist_similar'];
                        }
                        if ($retval['artist_arturl']) {
                            if ($bigartIsAlbum) {
                                $status['smallArtURL'] = $retval['artist_arturl'];
                            } else {
                                $status['bigArtURL'] = $retval['artist_arturl'];
                            }
                        }
                        if ($retval['album_arturl_large']) {
                            // when 'album_arturl_large' is set, 'album_arturl_medium' and 'album_arturl_small' are also set
                            if ($bigartIsAlbum) {
                                $status['mainArtURL'] = $retval['album_arturl_medium'];
                                $status['bigArtURL'] = $retval['album_arturl_medium'];
                            } else {
                                $status['mainArtURL'] = $retval['album_arturl_small'];
                                $status['smallArtURL'] = $retval['album_arturl_small'];
                            }
                        }
                    } else {
                        ui_notify('Radio fail ', $rts.' seconds, change status '.$status['changed']);
                    }
                    if (!$status['currentartist']) {
                        $status['currentartist'] = 'Streaming';
                        $status['currentalbumartist'] = 'Streaming';
                    }
                    if (!$status['currentsong']) {
                        $status['currentsong'] = 'Radio';
                    }
                }
                if ($status['changed'] === 'mixer') {
                    //$redis->set('current_volume', $status['volume']);
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }
                $status['actPlayer'] = "MPD";
                $redis->set('act_player_info', json_encode($status));

                // Global Random
                if ($redis->hGet('globalrandom', 'enable') && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // save JSON response for extensions
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                If ($redis->hGet('globalrandom', 'enable') && ($status['state'] === 'play') && ($redis->get('nextsongid') === '')) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                $errorcode = socket_last_error($socket);
                runelog('MPD last socket error = ', $errorcode);
                wrk_clean_music_metadata($redis);
            } while (($errorcode === 0) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } elseif ($activePlayer === 'Spotify') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $status['radio'] = false;
            $status = array();
            do {
                $status = monitorSpopState($socket);
                $status['playlist'] = $redis->hGet('spotify', 'plversion');
                ui_render('playback', json_encode($status));
                runelog('rune_PL_wrk: UI JSON', $status);
                runelog('rune_PL_wrk: close SPOP socket');
                // save JSON response for extensions
                $status['actPlayer'] = "Spotify";
                $redis->set('act_player_info', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('Spotify last socket error = ', $errorcode);
            } while  (($errorcode === 0) && ($redis->get('activePlayer') === 'Spotify'));
            closeSpopSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            $status['radio'] = false;
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "play";
                $status['time'] = "0";
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentalbumartist'] = "Airplay";
                $status['currentartist'] = "Airplay";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $status['actPlayer'] = "Airplay";
                $status['radioname'] = null;
                $status['OK'] = null;
                $status['mainArtURL'] = $artUrl.'/airplay.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            do {
                sleep(2);
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            $status['radio'] = false;
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "stop";
                $status['time'] = "0";
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentalbumartist'] = "SpotifyConnect";
                $status['currentartist'] = "SpotifyConnect";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $status['actPlayer'] = "SpotifyConnect";
                $status['radioname'] = null;
                $status['OK'] = null;
                $status['mainArtURL'] = $artUrl.'/spotify-connect.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                $playing = reset(sysCmd('cat /proc/asound/card*/pcm*p/sub*/hw_params | grep -c -i -v closed'));
                // $playing contains 0 or false when nothing is playing, otherwise a positive number like 7 (=true)
                runelog('rune_PL_wrk: $playing:', $playing);
                // if (($redis->hGet('spotifyconnect', 'event') != 'stop') || $playing) {
                if ($playing) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis, 'SpotifyConnect');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                sleep(2);
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
        } else {
            $forceupdate = 1;
            sleep(1);
        }
        $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!

