#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_SY_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
$start = microtime(true);
$smartctl_microtime_then = $start;
$smartctl_check_minutes = 20;
$savecpu = 0;
ini_set('display_errors', '1');
error_reporting(E_ALL & ~E_NOTICE);
ini_set('error_log', '/var/log/runeaudio/rune_SY_wrk.log');
define('APP', '/srv/http/app/');
include('/srv/http/app/libs/runeaudio.php');
// setup /run dir
sysCmd('chmod 777 /run');

// Connect to Redis backend
$redis = new Redis();
$redis->connect('/run/redis.sock');

// if os updates are needed
if (file_exists('/srv/http/command/update_os.php')) {
    include '/srv/http/command/update_os.php';
    updateOS($redis);
}

// clean up Rern's addons security
// Rern's addons menu
if ($redis->hGet('addons', 'addo') != '') {
	// do nothing
} else {
	// not set or is empty so delete the sudo enable-all file for user http - used for addons menu
	sysCmd('rm -f /etc/sudoers.d/http');
}
// Rern's restore (as in backup) enable
// always delete the sudo enable-all file for user http ans disable the redis 'restore activate' entry - used for backup restore
sysCmd('rm -f /etc/sudoers.d/http-backup');
$redis->set('restoreact', 0);

// determine the actual mpd player version
$retval = sysCmd("mpd --version | grep -o 'Music Player Daemon.*' | cut -f4- -d' '");
$mpdversion = trim($retval[0]);
unset($retval);

// read registered HW architecture
$arch_db = $redis->get('hwplatformid');
runelog('registered architecture: ', $arch_db);
$playerid_db = $redis->get('playerid');
runelog('registered playerid: ', $playerid_db);

// initialize Redis worker data tables
$redis->del('w_lock');
$redis->del('w_queue');
$redis->del('notifications');

// reset worker logfile
sysCmd('echo "--------------- start: rune_SY_wrk.php ---------------" > /var/log/runeaudio/rune_SY_wrk.log');
runelog('WORKER rune_SY_wrk.php STARTING...');
// INITIALIZE ENVIRONMENT --- //
runelog('INITIALIZE ENVIRONMENT ---');

// check Architecture
$arch = wrk_getHwPlatform($redis);
runelog('detected architecture: ', $arch);
if ($arch_db !== $arch) {
    runelog('architecture mismatch: registered HWID: '.$arch_db.' detected: ', $arch);
    // reset playerID if architectureID not match. This condition "fires" another first-run process
    $playerid_db = '';
}

// check git branch
$gitbranch = sysCmd("cd /var/www/ ; git branch | grep \"*\" | cut -d ' ' -f 2");
runelog('GIT BRANCH: ', $gitbranch[0]);
$redis->hSet('git', 'branch', $gitbranch[0]);

if ($playerid_db === '') {
    // RUNEAUDIO FIRST RUN PROCESS --- //
    runelog('>>>>>>RUNEAUDIO FIRST RUN PROCESS ---');
    // reset critical file permissions to default
    runelog('reset critical file permissions to default');
    wrk_sysAcl();
    // reset Redis Player Datastore
    runelog('invoke Redis player datastore reset');
	sysCmd('/var/www/db/redis_datastore_setup reset');
    // register HW architectureID and playerID
    runelog('register HW architectureID and playerID');
    wrk_setHwPlatform($redis);
    // reset netconf to defaults
    runelog('reset netconf to defaults');
    // read system network interfaces details
    wrk_netconfig($redis,'reset');
	// reset USB mounts
	runelog('invoke USB mounts reset');
	sysCmd('/srv/http/command/usbmount');
    // reset sourcecfg to defaults
    runelog('reset sourcecfg to defaults');
	wrk_mpdconf($redis,'stop');
    wrk_sourcecfg($redis,'reset');
    // reset Webradios
    $redis->del('webradios');
    sysCmd('rm /mnt/MPD/Webradio/*');
    // reset mpdconf to defaults
    runelog('reset mpdconf to defaults');
    wrk_mpdconf($redis, 'reset');
	// check that mpd is running
	$retval = sysCmd('systemctl is-active mpd');
	if ($retval[0] === 'active') {
		// do nothing
	} else {
		sysCmd('systemctl start mpd');
	}
	unset($retval);
	// ashuffle gets started automatically
    // reconnect to new instance of MPD
    // clear MPD database
    //$mpd = openMpdSocket('/run/mpd.sock', 0);
    //sendMpdCommand($mpd, 'update');
	sysCmd('mpc update');
    // system ENV files check and replace
        // runelog("system ENV files check and replace",'');
        // wrk_sysEnvCheck($arch,1);
    // set HOSTNAME << TODO: integrate in wrk_sysEnvCheck >>
    wrk_avahiconfig($redis, strtolower(trim($redis->get('hostname'))));
    runelog('--- RUNEAUDIO FIRST RUN PROCESS');
    // invoke rune_SY_wrk respawn
    sysCmd('systemctl daemon-reload');
    sysCmd('systemctl restart rune_SY_wrk');
    // --- RUNEAUDIO FIRST RUN PROCESS //
} else if ($redis->hGet('mpdconf', 'version') != $mpdversion) {
    // MPD VERSION HAS CHANGED PROCES--- //
    runelog('>>>>>>MPD VERSION HAS CHANGED PROCESS ---');
	// set up file protections and ownership
    wrk_sysAcl();
    // check Redis Player Datastore
    runelog('invoke Redis player datastore check');
	sysCmd('/var/www/db/redis_datastore_setup check');
	// stop MPD and associated services
    wrk_mpdconf($redis,'stop');
	// reset mpdconf to defaults (also restarts mpd)
    runelog('reset mpdconf to defaults');
    wrk_mpdconf($redis,'reset');
	// reset sourcecfg to defaults
    runelog('reset sourcecfg to defaults');
    wrk_sourcecfg($redis,'reset');
    // reconnect to new instance of MPD
	$retval = sysCmd('systemctl is-active mpd');
	if ($retval[0] === 'active') {
		// do nothing
	} else {
		sysCmd('systemctl start mpd');
	}
	unset($retval);
	// ashuffle gets started automatically
    // clear MPD database
    //$mpd = openMpdSocket('/run/mpd.sock', 0);
    //sendMpdCommand($mpd,'update');
	sysCmd('mpc update');
    sleep(1);
    runelog('--- MPD VERSION HAS CHANGED PROCESS');
    // invoke rune_SY_wrk respawn
    sysCmd('systemctl daemon-reload');
    sysCmd('systemctl restart rune_SY_wrk');
    // --- MPD VERSION HAS CHANGED PROCESS//
} else {
    runelog('--- INITIALIZE ENVIRONMENT');
    // --- INITIALIZE ENVIRONMENT //
    // NORMAL STARTUP --- //
    runelog('NORMAL STARTUP ---');
    // NTP sync
    $start2 = microtime(true);
    $firstlap = $start2-$start;
    //runelog('NTP sync', $redis->get('ntpserver'));
    //wrk_NTPsync($redis->get('ntpserver'));
    $start3 = microtime(true);

	// call chrony and wait for time to be set. 12 tries x 10 second between attempts is maximum 2 minutes
	// normally by this point time has been set, if not there is probably no internet connection
	// the problem is that several jobs (incl. php-fpm) will crash and core dump if a large time change takes place while it is running
	// beter to wait for chrony to do its initial synchronisation as the core dumps take cpu resources and time
	sysCmd('chronyc waitsync 12');

    // check HOSTNAME << TODO: integrate in wrk_sysEnvCheck >>
	$retval = sysCmd('hostname');
    $hn = trim($retval[0]);
	if (strtolower($hn) != strtolower(trim($redis->get('hostname')))) {
		wrk_changeHostname($redis, $redis->get('hostname'));
	}
	unset($retval);

	// read activePlayer state
	$activePlayer = $redis->get('activePlayer');
	if ($activePlayer === 'MPD') {
		// stop spotify, if started
		sysCmd('pgrep -x spopd && systemctl stop spopd');
		// check MPD process, it can be stared earlier
		$retval = sysCmd('systemctl is-active mpd');
		if ($retval[0] === 'active') {
			// do nothing
		} else {
			// Start and refresh MPD (audio hardware status - soundcards and MPD config)
			wrk_mpdconf($redis,'refresh');
		}
		unset($retval);
		// ashuffle gets started automatically
	} else if ($activePlayer === 'Spotify') {
		// check MPD process, it can be started earlier
		$retval = sysCmd('systemctl is-active mpd');
		if ($retval[0] === 'active') {
			// stop mpd with kill, this saves the state-file
			sysCmd('mpd --kill');
		}
		unset($retval);
		// start spotify, if not started
		sysCmd('pgrep -x spopd || systemctl start spopd');
	} else {
		// stop spotify, if started
		sysCmd('pgrep -x spopd && systemctl stop spopd');
		// reset activePlayer state to MPD (default) & check MPD process, it can be started earlier
		$redis->set('activePlayer', 'MPD');
		$retval = sysCmd('systemctl is-active mpd');
		if ($retval[0] === 'active') {
			// do nothing
		} else {
			// Start and refresh MPD (audio hardware status - soundcards and MPD config)
			wrk_mpdconf($redis,'refresh');
		}
		unset($retval);
		// ashuffle gets started automatically
	}

	// check ENV files
    //if ($arch !== '--') {
        // wrk_sysOBEnvCheck($arch,0);
    //}

    // start Samba services (if required)
	wrk_restartSamba($redis);

	$kernel = $redis->get('kernel');
	// load i2smodule
	if ($redis->get('i2smodule') !== 'none') {
		switch($arch_db) {
			case '01':
				if ($kernel !== 'linux-rune-3.6.11-18-ARCH+') $loadi2s = true;
				break;
			case '10':
				$loadi2s = true;
				break;
		}
		if ($loadi2s === true) wrk_i2smodule($redis, $redis->get('i2smodule'));
	}
	// start shairport-sync
	if ($redis->hGet('airplay', 'enable')) {
		runelog("service: SHAIRPORT start",'');
		// create a directory to use for airplay metadata artwork
		// the location /srv/http/tmp is a tmpfs, see /etc/fstab
		// TO-DO: use the airplay redis variables to determine the metadata artwork directory
		sysCmd('mkdir -p /srv/http/tmp/airplay');
		sysCmd('cp /srv/http/assets/img/airplay-default.png /srv/http/tmp/airplay/airplay-default.png');
		sysCmd('chown -R http.http /srv/http/tmp');
		sysCmd('chmod 644 /srv/http/tmp/airplay/airplay-default.png');
		// start shairport-sync if it is not already started
		sysCmd('pgrep -x shairport-sync || systemctl start shairport-sync');
	}
	// start udevil
	if ($redis->get('udevil') === '1') {
		runelog("service: UDEVIL start",'');
		sysCmd('pgrep -x udevil || systemctl start udevil');
	}
	// read system network interfaces details
	// wrk_netconfig($redis,'setnics');
	// check /etc/network/interfaces integrity
	// hashCFG('check_net',$redis);
	// check /etc/mpd.conf integrity
	// hashCFG('check_mpd',$redis);

	// initialize OrionProfile
	runelog('env: SET KERNEL PROFILE',$redis->get('orionprofile'));
	sysCmd("/var/www/command/orion_optimize.sh ".$redis->get('orionprofile')." ".$redis->get('hwplatformid'));

	// start php-fpm if required
	$retval = sysCmd('systemctl is-active php-fpm');
	if ($retval[0] === 'active') {
		// do nothing
	} else {
		sysCmd('systemctl start php-fpm');
	}
	unset($retval);

	// PHP 5.5 OPCache
	if (!$redis->get('dev')) {
		// prime PHP OPCache
		runelog('prime PHP OPCache');
		sysCmdAsync("curl -s -X GET 'http://127.0.0.1/command/cachectl.php?action=prime'");
	}

	// start rune_PL_wrk
	sysCmd('pgrep -x rune_PL_wrk || systemctl start rune_PL_wrk');
	$start4 = microtime(true);
	$smartctl_microtime_then = $start4;
	$starttime = ($start4-$start3)+$firstlap;
	runelog('WORKER rune_SY_wrk.php STARTED in '.$starttime.' seconds.');
	ui_notify_async('system worker', 'rune_SY_wrk started in '.$starttime.' seconds.');

	// start the local browser
	if (($redis->get('local_browser')) && (file_exists('/usr/bin/xinit'))) {
		sysCmdAsync('pgrep -x local-browser || systemctl start local-browser');
	}

	// turn wifi power saving off
	sysCmd('iwconfig wlan0 power off');

	// close startup Redis connection
	$redis->close();
	// refresh nics status, set the mpd volume, collect debug data, set process priority (to nice) and check the contents of redis
	// mostly these commands will do nothing or very little, they are also not essential for the startup sequence
	sysCmdAsync('/var/www/command/refresh_nics ; /var/www/command/set_mpd_volume.php ; /var/www/command/debug_collector ; /srv/http/command/rune_prio nice ; /srv/http/db/redis_datastore_setup check');
	runelog('--- NORMAL STARTUP');
	// --- NORMAL STARTUP //
}
runelog('WORKER MAIN LOOP ---');
// WORKER MAIN LOOP --- //
$all_mounted = 0;
$retries_mounting = 0;
while (1) {
	// Connect to Redis backend
	$redis->pconnect('/run/redis.sock');
	// runelog('[wrk] loop marker ',microtime(true));
    // monitor loop
    if (!empty($redis->hGetAll('w_queue'))) {
        //debug
        runelog('[wrk] there is something for me in the queue! ');
        // switch command queue for predefined jobs
        foreach ($redis->hGetAll('w_queue') as $jobID => $job) {
            runelog('(loop) start job', $jobID);
            // decode redis data
            $job = json_decode($job);
            switch($job->wrkcmd) {
                case 'test':
                    runelog('wrk_SY: ', $job->action);
                    $redis->sAdd('w_lock', $jobID);
                    runelog("testjob: action ", $job->action);
                    runelog("testjob: args[] ", $job->args);
                    // send notfy to UI
                    ui_notify_async('Test', 'text message: jobID='.$jobID, $jobID);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'airplay':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if ($job->args !== $redis->hGet('airplay', 'name')) {
                        $redis->hSet('airplay', 'name', $job->args);
                        // update shairport startup config
                        wrk_shairport($redis, $redis->get('ao'), $redis->hGet('airplay', 'name'));
                        $restart = 1;
                    }
                    // start shairport
                    if ($job->action === 'start') {
                        runelog('service: SHAIRPORT start');
						// create a directory to use for airplay metadata artwork
						// the location /srv/http/tmp is a tmpfs, see /etc/fstab
						// TO-DO: use the airplay redis variables to determine the metadata artwork directory
						sysCmd('mkdir -p /srv/http/tmp/airplay');
						sysCmd('cp /srv/http/assets/img/airplay-default.png /srv/http/tmp/airplay/airplay-default.png');
						sysCmd('chown -R http.http /srv/http/tmp');
						sysCmd('chmod 644 /srv/http/tmp/airplay/airplay-default.png');
                        // start or re-start shairport-sync service
                        if (isset($restart)) {
                            sysCmd('systemctl reload-or-restart shairport-sync');
                        } else {
                            sysCmd('systemctl start shairport-sync');
                        }
                        $redis->hSet('airplay', 'enable', 1);
                        // send notfy to UI
                        ui_notify_async('AirPlay', 'AirPlay feature enabled', $jobID);
                    }
                    // stop shairport
                    if ($job->action === 'stop') {
                        runelog('service: SHAIRPORT stop');
                        sysCmd('systemctl stop shairport-sync');
                        $redis->hSet('airplay', 'enable', 0);
                        // send notfy to UI
                        ui_notify_async('AirPlay', 'AirPlay feature disabled', $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'backup':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    $backup = wrk_backup($redis);
                    $redis->hSet('w_msg', $jobID, $backup);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'restoreact':
                    runelog('wrk_SY: ', $job->wrkcmd);
					// Activate the Restore function
                    $redis->sAdd('w_lock', $jobID);
					$redis->set('restoreact', ' 1');
					sysCmd("echo 'http ALL=NOPASSWD: ALL' > /etc/sudoers.d/http-backup");
                    $redis->sRem('w_lock', $jobID);
                    break;
                // case 'restore':
                    // runelog('wrk_SY: ', $job->wrkcmd);
					// runelog('restore: ', $job->args);
                    // $redis->sAdd('w_lock', $jobID);
					// ui_notify_async('Restore backup', 'please wait for a restart...', $jobID);
                    // wrk_restore($redis, "/run/".$job->args);
					// this function never returns, it will stop most jobs restart redis and finally respawn rune_SY_wrk (this file)
                    // $redis->sRem('w_lock', $jobID);
                    // break;
                case 'clearimg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    // Clean IMG
                    runelog('Clean IMG');
                    // send notfy to UI
                    //ui_notify_async('Clean IMG', 'Started, this can take a while to complete', $jobID);
                    ui_notify('Clean IMG', 'Started, this can take a while to complete');
                    // enable OPcache
                    wrk_opcache('enable');
                    wrk_cleanDistro();
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'debug':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    sysCmd('/var/www/command/debug_collector');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'dlna':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					sysCmd('systemctl stop upmpdcli');
                    if (($job->args->name !== $redis->hGet('dlna', 'name')) OR ($job->args->queueowner !== $redis->hGet('dlna', 'queueowner'))) {
                        $redis->hSet('dlna', 'name', $job->args->name);
                        $redis->hSet('dlna', 'queueowner', $job->args->queueowner);
                        // update upmpdcli startup config
                        wrk_upmpdcli($redis, $redis->hGet('dlna', 'name'), $redis->hGet('dlna', 'queueowner'));
                    }
                    // start upmpdcli
                    if ($job->action === 'start') {
                        runelog('service: UPMPDCLI start');
                        // start or re-start upmpdcli service
                        sysCmd('systemctl start upmpdcli');
                        $redis->hSet('dlna', 'enable', 1);
                        // send notfy to UI
                        ui_notify_async('UPnP / DLNA', 'UPnP / DLNA feature enabled', $jobID);
                    }
                    // stop upmpdcli
                    if ($job->action === 'stop') {
                        runelog('service: UPMPDCLI stop');
                        $redis->hSet('dlna', 'enable', 0);
                        // send notfy to UI
                        ui_notify_async('UPnP / DLNA', 'UPnP / DLNA feature disabled', $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'gitpull':
                    runelog('wrk_SY: ', $job->wrkcmd);
					$redis->sAdd('w_lock', $jobID);
                    // Update RuneUI
                    runelog('Update RuneUI');
					// preparation: delete the MPD watchdog, set up git user-name and email (set to player ID)
					sysCmd('rm -f /var/www/command/mpd-watchdog');
					sysCmd('cd /srv/http/ && git config user.name "'.$redis->get('playerid').'"');
					sysCmd('cd /srv/http/ && git config user.email "'.$redis->get('playerid').'@runeaudio.com"');
                    // git stash, git add then git pull
                    $retval = sysCmd('cd /srv/http/ && git stash ; git add . ; git pull');
                    //sysCmd("curl -s -X GET 'http://localhost/clear'");
                    // send notfy to UI
                    ui_notify('Update RuneUI', 'RuneUI update message<br>'.implode('<br>', $retval));
					unset($retval);
                    sysCmd('cd /srv/http/ && git stash');
					wrk_sysAcl();
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'hostname':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					ui_notify('Settings - Change Hostname', 'it takes some time .....');
                    wrk_changeHostname($redis, $job->args);
					$retval = sysCmd('hostname');
                    $hn = trim($retval[0]);
					if (strtolower($hn) === strtolower(trim($job->args))){
						$redis->set('hostname', trim($job->args));
					} else {
						$redis->set('hostname', $hn);
					}
					unset($retval);
                    // update hash
                    $hash = md5_file('/etc/mpd.conf');
                    $redis->set('mpdconfhash', $hash);
                    // send notfy to UI
                    //ui_notify_async('Hostname', 'Hostname changed to:'.$hn, $jobID);
                    ui_notify('Hostname', 'Hostname changed to:'.$hn);
					sleep(2);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'i2smodule':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    runelog('env: SET I2S MODULE', $job->args);
                    wrk_i2smodule($redis, $job->args);
                    // send notification
                    // TODO: make a real check!
                    ui_notify_async('I&#178;S kernel module', 'Operation completed', $jobID);
                    // TODO (rework needed)
                    $ao = $redis->get('ao');
                    runelog('env: reenable the current AO', $ao);
                    if ($ao === 'bcm2835 ALSA_1' OR $ao === 'bcm2835 ALSA_2') {
                        sysCmd('mpc enable only "bcm2835 ALSA"');
                    } else {    
                        sysCmd('mpc enable only "'.$ao.'"');
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'audio_on_off':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    runelog('env: SET dtparam-audio', $job->args);
                    wrk_audio_on_off($redis, $job->args);
                    // send notification
                    // TODO: make a real check!
                    ui_notify_async('Switching onboard audio mode', 'Operation completed', $jobID);
                    // TODO (rework needed)
                    $ao = $redis->get('ao');
                    runelog('env: reenable the current AO', $ao);
                    if ($ao === 'bcm2835 ALSA_1' OR $ao === 'bcm2835 ALSA_2') {
                        sysCmd('mpc enable only "bcm2835 ALSA"');
                    } else {    
                        sysCmd('mpc enable only "'.$ao.'"');
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'kernelswitch':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    runelog('env: SWITCH KERNEL',$job->args);
                    if (wrk_kernelswitch($redis,$job->args)) {
                        if ($job->args === 'linux-rune-rpi_3.12.13-rt21_wosa') {
                            $redis->set('ao', 'snd_rpi_wsp_1');
                            $redis->set('i2smodule', 'none');
                            $redis->set('orionprofile', 'OrionV2');
                        }
                        $notification = new stdClass();
                        $notification->title = 'Kernel switch';
                        $notification->text = $job->args.' selected successfully, reboot reqired';
                        wrk_notify($redis, 'kernelswitch', $notification, $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'lastfm':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if ($job->action === 'start') {
                        if ($job->args->user != $redis->hGet('lastfm', 'user') OR $job->args->pass != $redis->hGet('lastfm', 'pass')) {
                        // mpdscribble.conf
                        $file = '/etc/mpdscribble.conf';
                        $newArray = wrk_replaceTextLine($file, '', 'username =', 'username = '.$job->args->user, 'last.fm', 2);
                        $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$job->args->pass, 'last.fm', 3);
                        // Commit changes to /etc/mpdscribble.conf
                        $fp = fopen($file, 'w');
                        fwrite($fp, implode("", $newArray));
                        fclose($fp);
						unset($newArray);
                        // write LastFM auth data to Redis datastore
                        setLastFMauth($redis, $job->args);
                        }
                        // check if spotify is configured
                        if ($redis->hGet('spotify','enable') === '1') {
                            // spopd.conf
                            $file = '/etc/spop/spopd.conf';
                            $newArray = wrk_replaceTextLine($file, '', 'username =', 'username = '.$redis->hGet('lastfm','user'), 'api_endpoint', 1);
                            $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$redis->hGet('lastfm','pass'), 'api_endpoint', 2);
                            $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', 'plugins = scrobble', '### System settings ###', 2);
                            // commit changes to /etc/spop/spopd.conf
                            $fp = fopen($file, 'w');
                            fwrite($fp, implode("", $newArray));
                            fclose($fp);
							unset($newArray);
                            if ($redis->get('activePlayer') === 'Spotify') {
                                sysCmd('systemctl reload-or-restart spopd || systemctl start spopd');
                            }
                        }
                        sysCmd('systemctl stop mpdscribble');
                        runelog('service: MPDSCRIBBLE start');
                        sysCmd('systemctl start mpdscribble');
                        // send notfy to UI
                        ui_notify_async('Last.FM scrobbling', 'mpdscribble daemon started', $jobID);
                        $redis->hSet('lastfm', 'enable', 1);
                    }
                    if ($job->action === 'stop') {
                        runelog('service: MPDSCRIBBLE stop');
                        sysCmd('systemctl stop mpdscribble');
                        // check if spotify is configured
                        if ($redis->hGet('spotify','enable') === '1') {
                            // spopd.conf
                            $file = '/etc/spop/spopd.conf';
                            $newArray = wrk_replaceTextLine($file, '', 'plugins =', '#plugins = scrobble', '### System settings ###', 2);
                            // commit changes to /etc/spop/spopd.conf
                            $fp = fopen($file, 'w');
                            fwrite($fp, implode("", $newArray));
                            fclose($fp);
							unset($newArray);
                            sysCmd('systemctl reload-or-restart spopd');
                        }
                        // send notfy to UI
                        ui_notify_async('Last.FM scrobbling', 'mpdscribble daemon stopped', $jobID);
                        $redis->hSet('lastfm', 'enable', 0);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'mpdcfg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if ($job->action === 'update') {
                        // send notfy to UI
                        ui_notify_async('MPD', 'configuration updated', $jobID);
                        runelog('args',$job->args);
                        wrk_mpdconf($redis, 'update', $job->args, $jobID);
                        wrk_mpdconf($redis, 'restart');
                    }
                    if ($job->action === 'reset') {
                        wrk_mpdconf($redis, 'reset');
                        wrk_mpdconf($redis, 'restart');
                    }
                    if ($job->action === 'switchao') {
                        wrk_mpdconf($redis, 'switchao', $job->args, $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'mpdcfgman':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    // send notfy to UI
                    ui_notify_async('MPD', 'configuration updated', $jobID);
                    // stop MPD daemon
                    wrk_mpdconf($redis, 'stop');
                    // write mpd.conf file
                    $fh = fopen('/etc/mpd.conf', 'w');
                    fwrite($fh, $job->args);
                    fclose($fh);
                    wrk_mpdconf($redis, 'start');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'mpdrestart':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    wrk_mpdconf($redis, 'restart');
                    $redis->sRem('w_lock', $jobID);
                    break;
                //case 'ashufflestart':
                    //runelog('wrk_SY: ', $job->wrkcmd);
                    //$redis->sAdd('w_lock', $jobID);
					// shuffle.service has the line: ExecStart=/usr/bin/ashuffle -f /var/lib/mpd/playlists/RandomPlayPlaylist.m3u
					// The hard coded /var/lib/mpd/playlists is set to $redis->hget('mpdconf', 'playlist_directory')
					// This will modify the standard shuffle.service to be able to random play from playlists
					//$file = '/usr/lib/systemd/system/ashuffle.service';
					//$newArray = wrk_replaceTextLine($file, '', 'ExecStart=', 'ExecStart=/usr/bin/ashuffle -f '.$redis->hGet('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u');
					//$fp = fopen($file, 'w');
					//$return = fwrite($fp, implode("", $newArray));
					//fclose($fp);
					//unset($newArray);
					// Restart ashuffle if global random ON
					//if ('1' === $redis->get('globalrandom')) {
						//sysCmd('systemctl daemon-reload');
						// ashuffle gets started automatically
					//}
                    //$redis->sRem('w_lock', $jobID);
                    //break;
                case 'ashufflereset':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					// If it exists, remove the symbolic link which ashuffle uses as a random playlist. ashuffle uses the whole MPD database in it is not present
					sysCmd('rm -f '.$redis->hget('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u');
					// set the indicator to say NO playlist random file exists
					$redis->set('last_pl_randomfile', 'none');
					// Stop ashuffle
					sysCmd('systemctl stop ashuffle');
					// shuffle.service has the line: ExecStart=/usr/bin/ashuffle -f /var/lib/mpd/playlists/RandomPlayPlaylist.m3u
					// The hard coded /var/lib/mpd/playlists is set to $redis->hget('mpdconf', 'playlist_directory')
					// This will modify the standard shuffle.service to be able to random play from playlists
					$file = '/usr/lib/systemd/system/ashuffle.service';
					$newArray = wrk_replaceTextLine($file, '', 'ExecStart=', 'ExecStart=/usr/bin/ashuffle -f '.$redis->hGet('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u');
					$fp = fopen($file, 'w');
					$return = fwrite($fp, implode("", $newArray));
					fclose($fp);
					unset($newArray);
					// Restart ashuffle if global random ON
					if ('1' === $redis->get('globalrandom')) {
						sysCmd('systemctl daemon-reload');
						// ashuffle gets started automatically
					}
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'pl_ashuffle':
                    runelog('wrk_SY: ', $job->wrkcmd);
					runelog('pl_ashuffle args: ', $job->args);
                    $redis->sAdd('w_lock', $jobID);
					// Make a symbolic link to the selected playlist for random play, ashuffle will use it on startup if it is available
					sysCmd('ln -sf '.$redis->hget('mpdconf', 'playlist_directory').'/'.$job->args.'.m3u '.$redis->hget('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u');
					// set the indicator to say a playlist random file exists
					$redis->set('last_pl_randomfile', 'exists');
					// Stop ashuffle
					sysCmd('systemctl stop ashuffle');
					// Set global random ON
					$redis->set('globalrandom', '1');
					// ashuffle gets started automatically
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'addrandomtracks':
                    runelog('wrk_SY: ', $job->wrkcmd);
					runelog('addrandomtracks args: ', $job->args);
                    $redis->sAdd('w_lock', $jobID);
					// save the number of files to add
					$redis->set('addrandom', $job->args);
					// call ashuffle to add the specified number of tracks to the queue
					ui_notify('Add random tracks', implode("\n", sysCmd('ashuffle -o '.$job->args)));
					sleep(3);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'airplaymetadata':
                    runelog('wrk_SY: ', $job->wrkcmd);
					runelog('airplaymetadata action: ', $job->action);
                    $redis->sAdd('w_lock', $jobID);
					// start or stop rune_SSM_wrk
					if ($job->action == 'start') {
						sysCmd('systemctl start rune_SSM_wrk');
						sleep(2);
						sysCmd('renice 3 $(pgrep -w rune_SSM_wrk) || renice 3 $(pgrep -w rune_SSM_wrk)');
					} else if ($job->action == 'stop') {
						sysCmd('systemctl stop rune_SSM_wrk');
					}
                    $redis->sRem('w_lock', $jobID);
                    break;
				case 'sambaonoff':
                    runelog('wrk_SY: ', $job->wrkcmd);
					runelog('sambaonoff action: ', $job->action);
					runelog('sambaonoff args: ', $job->args);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('samba', 'enable', $job->action);
					$redis->hSet('samba', 'readwrite', $job->args);
					wrk_restartSamba($redis);
                    $redis->sRem('w_lock', $jobID);
					break;
				case 'sambarestart':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					wrk_restartSamba($redis);
                    $redis->sRem('w_lock', $jobID);
					break;
				case 'rerninstall':
				    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					ui_notify("Rern's Addons", 'it takes some time .....');
					sysCmd('rm -fr /home/rern');
					sysCmd('mkdir -m=777 -p /home/rern');
					sysCmd('rm -f ./install.sh');
					sysCmd('wget -vN https://github.com/rern/RuneAudio_Addons/raw/master/install.sh --output-file=/home/rern/Rern_Addons.log');
					sysCmd('chmod +x -v ./install.sh  >> /home/rern/Rern_Addons.log');
					sysCmd('./install.sh >> /home/rern/Rern_Addons.log');
					sleep(1);
					$retval = sysCmd("cat /home/rern/Rern_Addons.log | grep -Ei 'installed|please'");
					ui_notify("Rern's Addons", preg_replace('/[^A-Za-z0-9<>- ]/', '', implode(" ", $retval)));
					sleep(3);
					ui_notify("Rern's Addons", "You may need to reboot...");
					sleep(1);
					unset($retval);
					$redis->hSet('addons', 'update', '0');
					$redis->hSet('addons', 'font', '20170901');
                    sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
					$redis->sRem('w_lock', $jobID);
					break;
				case 'rernreinstall':
				    runelog('wrk_SY: ', $job->wrkcmd);
					ui_notify("Rern's Addons", 'it takes some time .....');
                    $redis->sAdd('w_lock', $jobID);
					sysCmd('rm -fr /home/rern');
					sysCmd('mkdir -m=777 -p /home/rern');
					sysCmd('rm -f ./install.sh');
					sysCmd('rm -f /usr/local/bin/uninstall_addo.sh');
					sysCmd('redis-cli del addons addo');
					sysCmd('wget -vN https://github.com/rern/RuneAudio_Addons/raw/master/install.sh --output-file=/home/rern/Rern_Addons.log');
					sysCmd('chmod +x -v ./install.sh  >> /home/rern/Rern_Addons.log');
					sysCmd('./install.sh >> /home/rern/Rern_Addons.log');
					sleep(1);
					$retval = sysCmd("cat /home/rern/Rern_Addons.log | grep -Ei 'installed|please'");
					ui_notify("Rern's Addons", preg_replace('/[^A-Za-z0-9<>- ]/', '', implode(" ", $retval)));
					sleep(3);
					ui_notify("Rern's Addons", "You may need to reboot...");
					sleep(1);
					unset($retval);
					$redis->hSet('addons', 'update', '0');
					$redis->hSet('addons', 'font', '20170901');
                    sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'xorgserverstart':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->set('local_browser', 1);
					sysCmd('systemctl start local-browser');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'xorgserverstop':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->set('local_browser', 0);
					sysCmd('systemctl stop local-browser');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'airplayconfreset':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					sysCmd('cp /var/www/app/config/defaults/shairport-sync.service /usr/lib/systemd/system/shairport-sync.service');
					sysCmd('cp /var/www/app/config/defaults/shairport-sync.conf /etc/shairport-sync.conf');
					wrk_sysAcl();
					$airplay_name = $redis->hGet('airplay', 'name');
					$airplay_enable = $redis->hGet('airplay', 'enable');
					$redis->del('airplay');
					sysCmd('/var/www/db/redis_datastore_setup check');
					$redis->hSet('airplay', 'name', $airplay_name);
					$redis->hSet('airplay', 'enable', $airplay_enable);
					wrk_getHwPlatform($redis);
					wrk_shairport($redis, $redis->get('ao'), $airplay_name);
					$redis->sRem('w_lock', $jobID);
					break;
                case 'soxrmpdon':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->set('soxrmpdonoff', 1);
                    wrk_mpdconf($redis, 'refresh');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'soxrmpdoff':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->set('soxrmpdonoff', 0);
                    wrk_mpdconf($redis, 'refresh');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'soxrairplayon':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'soxronoff', 1);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'soxrairplayoff':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'soxronoff', 0);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'metadataairplayon':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'metadataonoff', 1);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'metadataairplayoff':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'metadataonoff', 0);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'artworkairplayon':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'artworkonoff', 1);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'artworkairplayoff':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					$redis->hSet('airplay', 'artworkonoff', 0);
					wrk_shairport($redis, $redis->get('ao'));
					$redis->sRem('w_lock', $jobID);
					break;
                case 'playernamemenu':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    runelog('playernamemenu action: ', $job->action);
                    $redis->sAdd('w_lock', $jobID);
					if ($job->action) {
						// on - player name and "Menu"
						$newline = '        <a id="menu-settings" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#" href="#"><?=$this->hostname ?> MENU <i class="fa fa-bars dx"></i></a> <!--- playernamemenu -->';
					} else {
						// off - "Menu" (default)
						$newline = '        <a id="menu-settings" class="dropdown-toggle" role="button" data-toggle="dropdown" data-target="#" href="#">MENU <i class="fa fa-bars dx"></i></a> <!--- playernamemenu -->';
					}
					$file = '/srv/http/app/templates/header.php';
					$newArray = wrk_replaceTextLine($file, '', '<!--- playernamemenu -->', $newline);
					// Commit changes to //srv/http/app/templates/header.php
					$fp = fopen($file, 'w');
					fwrite($fp, implode("", $newArray));
					fclose($fp);
					unset($newArray);
					sysCmd('chown http.http '.$file);
					sysCmd('chmod 644 '.$file);
					$redis->set('playernamemenu', $job->action);
                    sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
					$redis->sRem('w_lock', $jobID);
					break;
                case 'netcfg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    runelog('netcfg action: ', $job->action);
                    runelog('netcfg args: ', $job->args);
                    $redis->sAdd('w_lock', $jobID);
                    // reset network configuration to default
                    if ($job->action === 'reset') {
                        wrk_netconfig($redis,'reset',$job->args);
                        $redis->sRem('w_lock', $jobID);
                    }
                    // write network configuration
                    if ($job->action === 'config') {
                        // send notfy to UI
                        ui_notify('Networkconfiguration', 'it takes some time .....');
                        $retval = wrk_netconfig($redis, 'writecfg', $job->args);
                        $redis->sRem('w_lock', $jobID);
                        // reboot if needed !!!
                        if ($retval === 'reboot') {
                            //$notification = new stdClass();
                            //$notification->title = 'Network config';
                            //$notification->text = 'Config changed successfully, reboot reqired';
                            //wrk_notify($redis, 'kernelswitch', $notification, $jobID);
                            sysCmd('/var/www/command/rune_shutdown reboot');
                            sysCmdAsync('systemctl reboot');
                            //$redis->sRem('w_lock', $jobID);
                        }
						unset($retval);
                    }
                    // refresh network configuration
                    if ($job->action === 'refresh') {
                        sysCmd('/var/www/command/refresh_nics');
                        $redis->sRem('w_lock', $jobID);
                    }
                    // manual network configuration
                    if ($job->action === 'manual') {
                        // wrk_netconfig($redis,'manual',$job->args);
                        $redis->sRem('w_lock', $jobID);
                    }
                    break;
                case 'apcfg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    runelog('apcfg action: ', $job->action);
                    runelog('apcfg args: ', $job->args);
                    $redis->sAdd('w_lock', $jobID);
                    // reset accesspoint configuration to default
                    if ($job->action === 'reset') {
						// Need to test the following
                        // $redis->Del('AccessPoint');
						// sysCmd('/var/www/command/refresh_nics');
                        $redis->sRem('w_lock', $jobID);
                    }
                    // write network configuration
                    if ($job->action === 'config') {
                        // send notfy to UI
                        ui_notify('AccessPoint configuration', 'it takes some time .....');
                        $retval = wrk_apconfig($redis, 'writecfg', $job->args);
                        $redis->sRem('w_lock', $jobID);
                        // reboot if needed !!!
                        if ($retval === 'reboot') {
                            $notification = new stdClass();
                            $notification->title = 'AccessPoint config';
                            $notification->text = 'Config changed successfully, reboot reqired';
                            wrk_notify($redis, 'kernelswitch', $notification, $jobID);
                            sysCmd('/var/www/command/rune_shutdown reboot');
                            sysCmdAsync('systemctl reboot');
                        }
						unset($retval);
                    }
                    break;
                case 'ntpserver':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    $redis->set('ntpserver', wrk_NTPsync($job->args));
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'opcache':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    // Restart PHP service
                    if ($job->action === 'enable') {
                        wrk_opcache('enable', $redis);
                        runelog('PHP 5.5 OPcache enabled');
                        sysCmdAsync('systemctl reload-or-restart php-fpm || systemctl start php-fpm', 5);
                        // wrk_opcache('forceprime');
                        // send notfy to UI
                        ui_notify_async('PHP OpCache', 'cache enabled', $jobID);
                    } else {
                        wrk_opcache('disable', $redis);
                        runelog('PHP 5.5 OPcache disabled');
                        sysCmdAsync('systemctl reload-or-restart php-fpm || systemctl start php-fpm', 5);
                        // send notfy to UI
                        ui_notify_async('PHP OpCache', 'cache disabled', $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'orionprofile':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    $profile = $job->args." ".$redis->get('hwplatformid');
                    runelog("env: SET KERNEL PROFILE", $job->args);
                    sysCmd("/var/www/command/orion_optimize.sh ".$profile);
                    $redis->set('orionprofile', $job->args);
                    ui_notify_async('SoundSignature', 'Profile '.$profile.' applied', $jobID);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'phprestart':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    sysCmd('systemctl reload-or-restart php-fpm || systemctl start php-fpm');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'poweroff':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					// save the playback status
					wrk_mpdPlaybackStatus($redis);
					$redis->save();
                    // send notfy to UI
                    ui_notify_async('Shutdown', 'system shutdown in progress...', $jobID);
                    sysCmd('/var/www/command/rune_shutdown poweroff');
                    sysCmdAsync('poweroff');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'reboot':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
					// save the playback status
					wrk_mpdPlaybackStatus($redis);
					$redis->save();
                    // send notfy to UI
                    ui_notify_async('Reboot', 'system reboot in progress...', $jobID);
                    sysCmd('/var/www/command/rune_shutdown reboot');
                    sysCmdAsync('reboot');
                    $redis->sRem('w_lock', $jobID);
                    break;
				case 'display_off':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    sysCmd('export DISPLAY=:0; xset dpms force off');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'spotify':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if ($job->action === 'start') {
                        if ($job->args->user !== $redis->hGet('spotify', 'user') OR $job->args->pass !== $redis->hGet('spotify', 'pass')) {
                        // spopd.conf
                        $file = '/etc/spop/spopd.conf';
                        $newArray = wrk_replaceTextLine($file, '', 'spotify_username =', 'spotify_username = '.$job->args->user, '### Spotify auth settings ###', 2);
                        $newArray = wrk_replaceTextLine('', $newArray, 'spotify_password =', 'spotify_password = '.$job->args->pass, '### Spotify auth settings ###', 3);
                        // check if last.fm is configured
                        if ($redis->hGet('lastfm','enable') === '1') {
                            $newArray = wrk_replaceTextLine('', $newArray, 'username =', 'username = '.$redis->hGet('lastfm','user'), 'api_endpoint', 1);
                            $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$redis->hGet('lastfm','pass'), 'api_endpoint', 2);
                            $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', 'plugins = scrobble', '### System settings ###', 2);
                        } else {
                            $newArray = wrk_replaceTextLine('', $newArray, 'username =', '#username = user', 'api_endpoint', 1);
                            $newArray = wrk_replaceTextLine('', $newArray, 'password =', '#password = pass', 'api_endpoint', 2);
                            $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', '#plugins = scrobble', '### System settings ###', 2);
                        }
                        // commit changes to /etc/spop/spopd.conf
                        $fp = fopen($file, 'w');
                        fwrite($fp, implode("", $newArray));
                        fclose($fp);
						unset($newArray);
                        // write Spotify auth data to Redis datastore
                        $redis->hSet('spotify', 'user', $job->args->user);
                        $redis->hSet('spotify', 'pass', $job->args->pass); 
                        }
                        if ($redis->get('activePlayer') === 'Spotify') {
                            sysCmd('systemctl stop spopd');
                            runelog('service: SPOPD start');
                            sysCmd('systemctl start spopd');
                        }
                        // send notfy to UI
                        ui_notify_async('Spotify', 'Spotify client configured', $jobID);
                        $redis->hSet('spotify', 'enable',  1);
                    }
                    if ($job->action === 'stop') {
                        runelog('service: SPOPD stop');
                        sysCmd('systemctl stop spopd');
                        // send notfy to UI
                        ui_notify_async('Spotify', 'Spotify client stopped', $jobID);
                        $redis->hSet('spotify', 'enable',  0);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'sourcecfg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if (wrk_sourcecfg($redis, $job->action,$job->args)) sysCmd('mpc update');
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'switchplayer':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if (wrk_switchplayer($redis, $job->args)) {
                        ui_notify_async('Switch Player Engine', 'Current active player engine: '.$job->args, $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'sysAcl':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    wrk_sysAcl();
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'timezone':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    sysCmd('timedatectl set-timezone '.$job->args);
                    $redis->set('timezone', $job->args);
                    ui_notify_async('Timezone', 'Timezone updated.<br>Current timezone: '.$job->args, $jobID);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'udevil':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    if ($job->action === 'start') {
                    runelog('service: UDEVIL start');
                    sysCmd('systemctl start udevil');
                    $redis->set('udevil', 1);
                    ui_notify_async('USB-Auto', 'USB-Automount feature enabled', $jobID);
                    }
                    if ($job->action === 'stop') {
                    runelog('service: UDEVIL stop');
                    sysCmd('systemctl stop udevil');
                    $redis->set('udevil', 0);
                    ui_notify_async('USB-Auto', 'USB-Automount feature disabled', $jobID);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'webradio':
					runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    $mpd = openMpdSocket('/run/mpd.sock');
                    if ($job->action === 'add') {
                        runelog('service: WEBRADIO add', $job->args);
                        if (addRadio($mpd, $redis, $job->args)) {
                            ui_notify_async('Webradio', $job->args->label.' added to the library', $jobID);
                        }
                    }
                    if ($job->action === 'edit') {
                        runelog('service: WEBRADIO edit', $job->args);
                        if (editRadio($mpd, $redis, $job->args)) {
                            ui_notify_async('Webradio', $job->args->label.' modified succesfully', $jobID);
                        }
                    }
                    if ($job->action === 'delete') {
                        runelog('service: WEBRADIO delete', $job->args);
                        if (deleteRadio($mpd, $redis, $job->args)) {
                            ui_notify_async('Webradio', $job->args->label.' deleted', $jobID);
                        }
                    }
                    ui_libraryHome($redis);
                    closeMpdSocket($mpd);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'wificfg':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    // add profile
                    if ($job->action === 'add') {
                        runelog('wificfg: add profile for SSID: '.$job->args->ssid);
                        ui_notify_async('Adding WIFI-Profile', $job->args->ssid, $jobID);
                        wrk_wifiprofile($redis, $job->action, $job->args);
                        ui_notify_async('Added WIFI-Profile', $job->args->ssid, $jobID);
                    }
                    if ($job->action === 'edit') {
                        runelog('wificfg: edit profile for SSID: '.$job->args->ssid);
                        ui_notify_async('Changing WIFI-Profile', $job->args->ssid, $jobID);
                        wrk_wifiprofile($redis, $job->action, $job->args);
                        ui_notify_async('Changed WIFI-Profile', $job->args->ssid, $jobID);
                    }
                    if ($job->action === 'delete') {
                        runelog('wificfg: delete profile for SSID: '.$job->args->ssid);
                        ui_notify_async('Deleting WIFI-Profile', $job->args->ssid, $jobID);
                        wrk_wifiprofile($redis, $job->action, $job->args);
                        ui_notify_async('Deleted WIFI-Profile', $job->args->ssid, $jobID);
                    }
                    if ($job->action === 'disconnect') {
                        runelog('wificfg: disconnect profile for SSID: '.$job->args->ssid);
                        ui_notify_async('Disconnecting from WIFI-Profile', $job->args->ssid, $jobID);
                        wrk_wifiprofile($redis, $job->action, $job->args);
                        ui_notify_async('Disconnected from WIFI-Profile', $job->args->ssid, $jobID);
                    }
                    if ($job->action === 'connect') {
                        runelog('wificfg: connect profile for SSID: '.$job->args->ssid);
                        ui_notify_async('Connecting to WIFI-Profile', $job->args->ssid, $jobID);
                        wrk_wifiprofile($redis, $job->action, $job->args);
                        ui_notify_async('Connected to WIFI-Profile', $job->args->ssid, $jobID);
                    }
                    // inject random delay to avoid wifi scan overlapping
                    if ($job->action === 'scan') {
                        // random delay
//                        $sleep = rand(1000000, 2000000);
//                        usleep($sleep);
//                        $lock = $redis->Get('lock_wifiscan');
                    }
                    if ($job->action === 'scan') {
                        $lock = $redis->Get('lock_wifiscan');
                        if ($lock !== '1') {
                            runelog('wificfg: scan ');
                            // refresh nics status
                            sysCmdAsync('/var/www/command/refresh_nics');
                        } else {
                            runelog('wificfg: scan aborted. System locked, scan in progress.');
                        }
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'wrkrestart':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    $redis->sAdd('w_lock', $jobID);
                    // restart worker
                    sysCmd('systemctl reload-or-restart '.$job->args);
                    $redis->sRem('w_lock', $jobID);
                    break;
                case 'ui_notify':
                    runelog('wrk_SY: ', $job->wrkcmd);
                    // TODO: rework needed (fix bug in /var/www/index.php)
                    if (!isset($job->delay_us)) {
                        $job->delay_us = 650000;
                    }
                    runelog('delay_us '.$job->delay_us);
                    usleep($job->delay_us);
                    // send notify to RuneUI
                    foreach ($job->args as $raw_notification) {
                        wrk_notify($redis, 'raw', $raw_notification);
                    }
                    $redis->sRem('w_lock', $jobID);
                    break;
            } // end switch
            // delete processed job from the w_queue
            $redis->hDel('w_queue', $jobID);
            // emit endjob notification
            wrk_notify($redis, 'endjob', '', $jobID);
            runelog('(loop) delete job_queue', $jobID);
        } // end foreach loop
    } // end if loop
    // mount all sources
    if ($all_mounted === 0) {
        runelog('wrk_SY: try to mount all shares!');
        $all_mounted = wrk_sourcemount($redis, 'mountall');
        if ($retries_mounting > 20) {
            $all_mounted = 1;
        }
        if ($all_mounted === 1) {
            runelog('wrk_SY: all shares mounted successfully!');
            // start play if enabled
            if ($redis->get('mpd_autoplay')) {
				$redis->set('mpd_playback_laststate', 'playing');
				wrk_mpdRestorePlayerStatus($redis);
            }
        } else {
            $retries_mounting++;
            runelog('wrk_SY: error mounting shares, try it again! Count: '.$retries_mounting);
            usleep(500000);
        }
    }
	// The following parts are heavy on cpu time, run then only on every 15th cycle (= every +/-7 seconds)
	// this will allow the normal queued actions to be more responsive, waiting only 0,5 seconds in sleep state
	if ($savecpu++ > 15) {
		$savecpu = 0;
		// Detect deletion of playlist random file
		// Stop / restart ashuffle if the file RandomPlayPlaylist.m3u has been deleted
		// To-do: Better if the UI informs /db/index.php that it has deleted a file, then start the ashufflereset in /db/index.php
		$retval = sysCmd('systemctl is-active ashuffle');
		if ($retval[0] == 'active') {
			if (file_exists($redis->hget('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u')) {
				// file found
				$redis->set('last_pl_randomfile', 'exists');
				// clear the cache for the next time round - the function file_exists() uses cached information
				clearstatcache();
			} else {
				// no file found
				if ($redis->get('last_pl_randomfile') === 'exists') {
					// but the file was there the last time, so reset ashuffle
					// first delete the symlink, could be the symlink points to a non existing playlist (the function file_exists() will return false for this)
					// use unlink in place of rm to automatically clear the cache
					unlink($redis->hget('mpdconf', 'playlist_directory').'/RandomPlayPlaylist.m3u');
					// just stop ashuffle, it will start itself automatically (without a playlist random file)
					sysCmd('systemctl stop ashuffle');
					sleep(2);
					sysCmd('systemctl daemon-reload');
					sleep(2);
				}
				$redis->set('last_pl_randomfile', 'none');
				// no cache is stored for non-existant files
			}
		}
		unset($retval);
		// start Global Random if enabled - check continually, ashuffle get stopped for lots of reasons
		// this is the only place where ashuffle it is started
		// first check that it is enabled, not waiting for auto play to initialise and there are some songs to play
		//$retval = sysCmd('mpc stats | grep -i songs');
		//$mpdsongs = intval(preg_replace('/[^0-9]/', '', $retval[0]));
		//unset($retval);
		//$rerval = sysCmd('dir -l /mnt/MPD/*/* | grep -i total');
		//$songdirs = intval(preg_replace('/[^0-9]/', '', $retval[0]));
		//unset($retval);
		//if (($redis->get('globalrandom')) && (!$redis->get('ashuffle_wait_for_play')) && ($mpdsongs > 0) && ($songdirs > 0)) {
		if (($redis->get('globalrandom')) && (!$redis->get('ashuffle_wait_for_play'))) {
			$retval = sysCmd('systemctl is-active ashuffle');
			if ($retval[0] == 'active') {
				// already started, do nothing
				unset($retval);
			} else {
				// seems to be a bug somewhere in MPD
				// if ashuffle is started too quickly it loads many many (far TOO many) songs in the queue before MPD gets round to start playing one
				// wait until mpd has been running for a while before starting ashuffle
				unset($retval);
				$retval = sysCmd('ps -C mpd -o etimes=');
				$mpd_uptime = trim($retval[0]);
				if (intval($mpd_uptime) > intval($redis->get('ashuffle_start_delay'))) {
					sysCmd('pgrep -x ashuffle || systemctl start ashuffle');
					sysCmd('renice 20 $(pgrep -w ashuffle) || renice 20 $(pgrep -w ashuffle)');
				}
				unset($retval);
			}
		//} else {
		//	sysCmd('pgrep -x ashuffle && systemctl stop ashuffle');
		}
		// S.M.A.R.T. monitoring tools
		// will test each attached hard disk and tape unit
		// test only when something is playing and at a maximum rate of once per 19,5 minutes (set by the value of $smartctl_check_minutes)
		// why test only when something is playing?
		//	a) someone needs see the error messages and 
		//  b) most hard disks will be usb drives which go to sleep when not in use, let them sleep
		$smartctl_delta_minutes = round((microtime(true) - $smartctl_microtime_then)/60);
		if ($smartctl_delta_minutes > $smartctl_check_minutes) {
			// more than check minutes have past
			// store the microtime for the next cycle
			$smartctl_microtime_then = microtime(true);
			$retval = sysCmd('cat /proc/asound/card?/pcm?p/sub?/hw_params | grep -v closed');
			if (!empty(trim($retval[0]))) {
				// something is playing
				if (file_exists("/usr/bin/smartctl")) {
					// monitoring tools software is installed
					// scan for hard disks
					$drive_list = sysCmd('smartctl --scan-open -- -H -i -s on | grep -v aborted');
					if (!empty($drive_list)) {
						foreach($drive_list as $drive) {
							// for each connected drive
							$drive = trim($drive);
							if ($drive != "") {
								$command = "smartctl ".$drive." | grep -E 'Model:|Capacity:|-health self-'";
								$self_check = sysCmd($command);
								// the self check variable has 3 lines the third line must contain the word 'PASSED' or 'OK'
								if ((strpos(' '.$self_check[2], 'OK') === false) && (strpos(' '.$self_check[2], 'PASSED') === false)) {
									// there is a disk error, set the check frequency to 1,5 minutes and notify the UI
									ui_notify('Disk errors - Action required', implode("\n", $self_check));
									// set the disk check frquency to 1,5 minutes
									$smartctl_check_minutes = 2;
								}
							}
							unset($self_check);
							unset($command);
						}
						unset($drive);
						unset($drive_list);
					}
				}
			}
			unset($retval);
		}
	}
    // unload CPU: 0,5 second sleep
    usleep(500000);
} // end while loop
// --- WORKER MAIN LOOP //
// close Redis connection
$redis->close();
